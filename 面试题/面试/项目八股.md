## 项目八股

### 二 、Blog

#### 项目亮点

##### 1.使用自定义指令格式化日期，将pinia封装成一个模块统一注册导出

###### 组件内指令

```vue
<script setup>
// 在模板中启用 v-focus
const vFocus = {
  mounted: (el) => el.focus()
}
</script>

<template>
  <input v-focus />
</template>
```

```vue
<script>
export default{
  setup() {},
  directives: {
    // 指令名
    focus: {
      // 生命周期
      mounted(el) {
        // 处理DOM的逻辑
        el.focus();
      },
    }
  }
}
</script>
<template>
  <input v-focus />
</template>
```

###### 全局组件指令

```js
import { createApp } from 'vue'
import App from './App.vue'

const app = createApp(App)
app.directive('focus', {
  mounted(el) {
    el.focus();
  }
})
app.mount('#app')
```

###### 指令的生命周期

指令的生命周期和组件的生命周期类似：

```js
app.directive('focus', {
  created() {
    console.log('created');
  },
  beforeMount() {
    console.log('beforeMount');
  },
  mounted() {
    console.log('mounted');
  },
  beforeUpdate() {
    console.log('beforeUpdate');
  },
  updated() {
    console.log('updated');
  },
  beforeUnmount() {
    console.log('beforeUnmount');
  },
  unmounted() {
    console.log('unmounted');
  }
})
```

注意指令没有`beforeCreated`钩子。

- created：在绑定元素的属性前，或者事件监听器应用前调用
- beforeMount：在元素被插入到DOM前调用，例如我们想要实现输入框的自动聚焦，就不能在beforeMount钩子中实现
- mounted：在绑定元素的父组件以及自己的所有子节点都挂载完毕后调用，这个时候DOM已经渲染出来，我们实现输入框自动聚焦也是在这个钩子函数中实现
- beforeUpdate：绑定元素的父组件更新前调用
- updated：在绑定元素的父组件以及自己的所有子节点都更新完毕后调用
- beforeUnmount：绑定元素的父组件卸载前调用
- unmounted：绑定元素的父组件卸载后调用

###### 指令的参数

`el`：指令绑定到的DOM元素，可以用于直接操作当前元素，默认传入钩子的就是el参数，例如我们开始实现的`focus`指令，就是直接操作的元素DOM

`binding`：这是一个对象，包含以下属性：

- `value`：在元素上使用指令时，传递给指令的值。例如：`<div v-reverse="'hello'"></div>`，传递给`reserve`指令的值就是`hello`，我们可以拿到值并做相关处理
- `oldValue`：之前的值，一般用于`beforeUpate`和`updated`钩子函数中，例如：`beforeUpdate(el, {oldValue: ''})`
- `arg`：传递给指令的参数，非必需，例如`<div v-reverse:foo="'hello'"></div>`，那么传递给指令的参数就是`foo`
- `modifiers`：一个由修饰符构成的对象，例如`<div v-reverse.foo.bar="'hello'"></div>`，那么该修饰符对象为`{foo: true, bar: true}`，我们经常使用到的事件修饰符，其实和这个差不多。
- `instance`：使用该指令的组件实例，注意不是DOM
- `dir`：指令的定义对象

`vnode`：绑定元素的地城VNode

`preVnode`：之前的渲染中代表指令所绑定的元素的VNode，一般用于`beforeUpate`和`updated`钩子函数中

###### 指令用在自定义组件上



```vue
<script setup>
import ReverseVue from './Reserve.vue'
</script>
<template>
  <ReverseVue v-reserve="obj"/>
</template>

只有一个根节点
// Reverse.vue
<template>
    <!-- v-reserve  指令会被应用在此处 -->
    <div ></div>
</template>

两个根节点
<template>
    <!-- v-reserve 不会作用，并且会抛出警告 -->
    <div></div>
    <div></div>
</template>
```



##### 2.二次封装antd组件，封装对应的hooks，开发页面使用配置开发出通用组件

##### 3.对项目打包出的文件进行gzip压缩，配	置nginx缓存策略，优化访问速度

##### 4.前后端配合使用jwt进行鉴权功能，对不必要的请求进行节流优化

##### 5.使用oss存储对应的图片资源，使用base64配合sparkmd5解决重复上传图片

## 其他

### 你在前端开发中使用过哪些前端框架？它们有什么优缺点？在什么场景下使用它们最为合适？

在我的前端开发经验中，我使用过一些前端框架，包括React、Vue.js和Angular。下面是它们的优缺点以及适用场景的介绍：

React：React是一个非常流行的前端框架，它提供了一个组件化的架构来构建用户界面。React的最大优点是它的性能和灵活性。React使用虚拟DOM来减少对DOM的操作，提高了性能。此外，React的组件化架构使得代码具有高度的重用性和可维护性。React的缺点在于，它只关注视图层，如果需要使用其他库来管理状态、路由等等，就需要手动添加。React适用于构建单页面应用、大型应用和需要高度重用性的应用。

Vue.js：Vue.js是一个轻量级的前端框架，它提供了类似于React的组件化架构，但是相比于React更加容易上手。Vue.js的最大优点在于它的易用性和灵活性。Vue.js具有很好的文档和社区支持，容易学习和上手。Vue.js也提供了状态管理和路由等常用功能的内置支持。Vue.js的缺点在于，它的生态系统相对于React较小。Vue.js适用于构建中小型的应用程序和需要快速迭代的项目。